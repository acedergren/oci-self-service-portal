---
name: orchestrate
description: Coordinate parallel agent teams to execute multi-task implementation plans. Use when running phase tasks from the task plan, parallelizing independent implementation work, or executing custom plan files. Spawns isolated worktree agents with task ledger tracking, background monitoring, and wave-based quality gates.
---

# Orchestrate

Coordinate a team of parallel agents to execute a phase from the task plan. Manages task assignment, background monitoring, verification, scope enforcement, wave transition quality gates, and PRD requirement coverage tracking.

All agents are spawned via the `Task` tool with `isolation: "worktree"` — each agent gets a dedicated git worktree, eliminating file conflicts between parallel agents. Agents run in the background via `run_in_background: true`, with the orchestrator polling `TaskOutput` for completion.

## Resource Loading

**MANDATORY at Step 2**: Read `agent-roles.md` to determine role assignments and model selection.
**MANDATORY at prompt generation**: Read `prompt-templates/{role}.md` for each task's role to build the system prompt.
**MANDATORY at wave transitions**: Read `wave-template.md` for the pre/during/post checklist.
**Do NOT Load** prompt templates until you're ready to spawn agents — keep context lean.

## Critical Anti-Patterns

NEVER skip merge verification — an agent may have committed to its worktree but the merge back to the main branch could conflict. Always verify the merge succeeded and run quality gates after merging.

NEVER merge agent worktrees in parallel — sequential merges catch conflicts one at a time. Parallel merges create cascading three-way conflicts that are much harder to resolve.

NEVER assume worktree auto-cleanup happened — if an agent made no changes, Claude Code cleans up automatically. But if changes were committed, the worktree persists. Verify with `git worktree list` if in doubt.

NEVER let a worktree agent's commit go unverified — even if the Task result says "completed", the agent may have committed out-of-scope files or produced a commit that breaks the build. Always run the verification chain after merging back.

NEVER use `git add -A` in agent prompts — always stage specific files.

NEVER call TaskCreate before TeamCreate — tasks created in the global namespace are invisible to team agents via TaskList.

NEVER send requirement coverage claims without a verified commit — a test passing locally does not equal a committed, green build.

## Steps

### 1. Parse Arguments

Extract the orchestration target from `$ARGUMENTS`:

- **Phase ID** (e.g., `A`, `B`, `D`): Load tasks from `.claude/reference/phase-10-task-plan.md` for that phase
- **Plan file path** (e.g., `docs/plans/my-plan.md`): Parse tasks from the given file
- **Inline task list** (e.g., `"task1; task2; task3"`): Create tasks from semicolon-separated descriptions

Flags:

- **`--dry-run`**: Parse and display tasks without spawning agents
- **`--wave N`**: Start from wave N (skip earlier waves, assumes they're complete)
- **`--max-agents N`**: Cap concurrent agent count (default: 5)
- **`--max-turns N`**: Override default turns per agent (default: role-based from `agent-roles.md`)
- **`--no-qa`**: Skip spawning a dedicated QA watcher (not recommended)
- **`--no-prd`**: Skip PRD traceability tracking (use for plans not derived from a PRD)
- **`--verbose`**: Print all agent messages to the user (noisy but useful for debugging)

If no arguments, ask the user what to orchestrate.

**Check for PRD traceability**: If the plan file contains a `prd_req` column in its task tables (generated by `/prd --to-plan`), set `HAS_PRD=true` and load the PRD from `.claude/reference/PRD.md` to extract acceptance criteria. Initialize a requirement coverage map:

```
coverage = { "M1.2": "pending", "M1.3": "pending", ... }  // all prd_req IDs from the plan
```

### 2. Initialize Task Ledger

**IMPORTANT: TeamCreate MUST happen before TaskCreate.** Tasks created before a team exists land in the global namespace — agents cannot discover them via TaskList.

Use `TeamCreate` with a descriptive name derived from the phase:

- Phase A → team name `phase-A-foundation`
- Phase B → team name `phase-B-package-split`
- Custom plans → derive team name from the plan filename or `$ARGUMENTS`, or prompt user
- Inline tasks → `inline-<timestamp>`

For each task in the plan, use `TaskCreate` with:

- `subject`: Task title (e.g., "A-1.01 Update patch/minor runtime deps")
- `description`: Full task spec including files to modify, verification command, agent instructions,
  AND if `HAS_PRD=true`: the verbatim acceptance criteria block from the PRD for the linked requirement
- `activeForm`: Present-continuous description (e.g., "Updating runtime dependencies")
- `metadata`:
  ```json
  {
  	"role": "backend-impl",
  	"phase": "A",
  	"wave": "1",
  	"task_id": "A-1.01",
  	"estimated_duration": "20m",
  	"verify_command": "pnpm install && pnpm build",
  	"files": "package.json (root, api, frontend)",
  	"status_detail": "pending",
  	"prd_requirement": "M1.2"
  }
  ```
  Omit `prd_requirement` if this task has no linked PRD requirement.

Assign roles using the rules in `agent-roles.md`. The `role` field determines which prompt template to use and which model to select.

Set up `blockedBy` dependencies from the task plan's **Depends** column using `TaskUpdate`.

Print a summary:

```
Phase A: Dependency Updates + Fastify Hardening
  22 tasks (6 haiku, 16 sonnet) across 3 waves
  Wave 1: 6 tasks (all haiku, all parallel)
  Wave 2: 12 tasks (1 haiku, 11 sonnet)
  Wave 3: 4 tasks (2 haiku, 2 sonnet)
  PRD requirements tracked: 8 (M: 5, S: 3)
  Estimated: ~13 hours agent work
```

### 3. Spawn Agents for Wave

For each wave (starting from `--wave N` or wave 1):

#### a. Generate Prompts

For each task in the wave:

1. Determine the task's role from metadata (e.g., `backend-impl`)
2. Read the role-specific system prompt from `prompt-templates/{role}.md`
3. Build the task prompt by replacing template variables:
   - `{{TASK_DESCRIPTION}}` → task title + full description from ledger
   - `{{TASK_FILES}}` → files list from metadata
   - `{{VERIFY_COMMAND}}` → verification command from metadata
   - `{{COMPLETED_CONTEXT}}` → commit hashes + changed file summaries from completed tasks
4. If context from completed tasks is large, pre-read relevant code snippets and include them (truncate to keep total prompt under 20K tokens)

If `--dry-run`: Print all generated prompts and exit.

#### b. Spawn Background Agents

For each unblocked task (up to `--max-agents` concurrent), spawn via the Task tool:

```
Task({
  subagent_type: "general-purpose",
  isolation: "worktree",           // each agent gets an isolated git worktree
  run_in_background: true,         // non-blocking, returns task_id + output_file
  model: "{role.model}",           // from agent-roles.md (haiku/sonnet/opus)
  max_turns: {role.max_turns},     // soft budget control (prevents runaway agents)
  team_name: "{team_name}",
  name: "{role}-{N}",              // e.g., backend-1, qa-1, security-1
  prompt: "{generated prompt}"
})
```

Record the returned `task_id` for each spawned agent. Update task ledger: `TaskUpdate` → `status: in_progress`, add `{ "agent_task_id": "<task_id>" }` to metadata.

Always spawn one `qa-1` agent for continuous QA watching (per the QA Watcher Protocol) unless `--no-qa` is set.

### 4. Monitor Loop

Poll until all wave tasks complete. Check every 30 seconds:

```
For each running agent:
1. TaskOutput({ task_id: agent_task_id, block: false })
2. If completed:
   a. Read result from TaskOutput
   b. Extract worktree path and branch from result
   c. Verify commit exists in worktree: git -C <worktree_path> log --oneline -1
   d. Run merge-back protocol (Step 5)
   e. Reclaim slot, spawn next unblocked task from wave
3. If still running: continue polling
4. If max_turns exceeded: agent auto-stops — treat as budget exhaustion → failure escalation
```

**Status Report** (every 3 minutes or when the user asks):

```
+------------------------------------------+
| Phase A — Wave 2 Progress                |
+------------------------------------------+
| Completed: 6/12  | In Progress: 3       |
| Pending: 3       | Failed: 0            |
+------------------------------------------+
| backend-1:  A-2.04 Valkey cache     [##-]|
| backend-2:  A-2.10 OracleStore      [#--]|
| qa-1:       A-2.11 knip CI          [###]|
+------------------------------------------+
| PRD Coverage: M1.2 ✓  M1.3 ⋯  S2.1 ⋯   |
+------------------------------------------+
```

### 5. Merge-Back Protocol

After each agent completes, merge its worktree changes back to the main branch. **Merge sequentially** — one agent at a time within each wave. This prevents cascading conflicts.

```
For each completed agent:
1. Read the worktree path and branch from the Task result
2. From the main worktree:
   git merge <agent-branch> --no-edit
3. If merge succeeds:
   - Run the task's verify_command from metadata
   - If verified:
     - TaskUpdate → status: completed, add commit hash to metadata
     - If task had prd_requirement: update coverage map
     - Print: "✓ Task A-2.04 merged (commit abc1234)"
   - If verify fails:
     - git reset --merge  (undo the merge)
     - Enter failure escalation (Step 7)
4. If merge conflicts:
   - git merge --abort
   - Create a fix task: "Resolve merge conflict for {task} against {conflicting branch}"
   - Assign to an available agent, or pause for user intervention
5. Worktrees with no changes are auto-cleaned by Claude Code
```

### 6. Wave Transition Gate

When all tasks in a wave are complete (applies after all merges succeed):

1. Run full quality gate:

   ```bash
   pnpm build && npx vitest run && pnpm lint
   ```

2. If the phase's wave has a specific **Gate** command (from the task plan), run that too
3. Print wave coverage delta:
   ```
   Wave 2 complete. Requirements satisfied this wave: M1.2, M1.3
   Requirements still pending: S2.1 (queued for Wave 3)
   ```
4. **Gate passes** → Move to next wave, spawn new agents per Step 3
5. **Gate fails** → Diagnose the failure, create a fix task, spawn a fix agent, re-run gate

Read the wave checklist from `wave-template.md` for the full pre/during/post checklist.

### 7. Failure Escalation

Two-tier escalation for failed tasks:

**Tier 1 — Retry with context** (up to 2 retries):

- Spawn a new background Task agent with the error context appended to the original prompt
- Add prefix: "Previous attempt failed with the following error. Fix the issue and try again."
- Use the same model and max_turns

**Tier 2 — Model escalation** (after 2 retries fail):

- Escalate model: haiku → sonnet, sonnet → opus
- Extend max_turns: original × 1.5 (rounded up)
- Add prefix: "This task failed with a weaker model. You are a stronger model brought in to resolve it. Here is the full error history: ..."

**Tier 3 — User intervention** (if model escalation also fails):

- Print failure details: task description, error output, retry history
- Offer choices:
  - **Skip**: Mark task as skipped, continue with remaining tasks (may break downstream)
  - **Manual fix**: Pause orchestration, let user fix manually, then resume
  - **Abort**: Stop the entire orchestration

### 8. Phase Completion

When all waves are complete:

1. Run the phase's final verification (from the task plan's last wave Gate)
2. Run `/health-check --quick` for a comprehensive quality check
3. Print final summary with requirements coverage:

   ```
   Phase A Complete
     Tasks: 22/22 completed (2 retried, 0 skipped)
     Agents: 5 concurrent max
     Commits: 22
     Issues: 1 merge conflict (resolved), 1 model escalation
     Quality: All gates passed

   PRD Requirements Coverage:
     ✓ M1.1 — Auth token refresh (task A-1.02)
     ✓ M1.2 — Rate limiting per org (task A-2.04)
     ✓ M1.3 — Audit log blockchain (task A-3.01)
     ✓ S2.1 — Cache invalidation (task A-2.10)
     ✗ S2.2 — SKIPPED (out of scope for this phase)
   ```

4. **Auto-update PRD** (if `HAS_PRD=true` and coverage map has changes):
   - Call `/prd --update` with context: "Phase A complete. Mark these requirements as implemented:
     M1.1, M1.2, M1.3, S2.1. Update their status to [IMPLEMENTED] with implementation date and
     the commit range <first>..<last>."
5. Clean up worktrees: `git worktree prune`
6. Shut down any remaining team agents and clean up: `TeamDelete`

### 9. Cross-Phase Handoff

If more phases are queued (following the Phase Dependency DAG):

1. Check which phases are now unblocked (e.g., after A completes → B, D, F are unblocked)
2. For parallel phases, start a new orchestration cycle for each unblocked phase
3. Report to user which phases are starting in parallel

## Arguments

- `$ARGUMENTS`: Phase ID, plan file path, or inline task list. Optional flags:
  - `--dry-run`: Parse and display tasks without spawning agents
  - `--wave N`: Start from wave N (skip earlier completed waves)
  - `--max-agents N`: Cap concurrent agent count (default: 5)
  - `--max-turns N`: Override default turns per agent (default: role-based from `agent-roles.md`)
  - `--no-qa`: Skip spawning a dedicated QA watcher (not recommended)
  - `--no-prd`: Skip PRD traceability (for plans not derived from a PRD)
  - `--verbose`: Print all agent messages to the user (noisy but useful for debugging)

## Integration Points

### Skill Pipeline

```
/prd                    → .claude/reference/PRD.md  (living requirements)
  └─ /prd --to-plan     → docs/plans/<feature>-plan.md  (task table with prd_req column)
       └─ /orchestrate  → spawns team, assigns tasks with Given/When/Then context
            └─ agents: /implement  (tests written against PRD acceptance criteria)
            └─ on complete: coverage map updated, /prd --update called at phase end
```

### Role Registry

- **`agent-roles.md`** — Maps tasks to specialist roles (model, max turns, prompt template)

### Prompt Templates

- **`prompt-templates/backend-impl.md`** — Fastify 5 routes, plugins, services
- **`prompt-templates/frontend-impl.md`** — SvelteKit pages, components, stores
- **`prompt-templates/mastra-impl.md`** — Mastra agents, RAG, tools, workflows
- **`prompt-templates/security-reviewer.md`** — OWASP + Oracle security review
- **`prompt-templates/qa-lead.md`** — TDD, test writing, QA watching
- **`prompt-templates/doc-sync.md`** — Documentation sync

### Referenced Skills

- **`/implement`** — Agents use this for implementation tasks (combines pre-flight + TDD + scope guard + quality commit). When the task carries a `prd_requirement`, agents write tests from the PRD's Given/When/Then acceptance criteria blocks.
- **`/quality-commit`** — Fallback for tasks that don't need the full `/implement` pipeline (config changes, docs, simple moves)
- **`/review-all`** — Run at phase completion for comprehensive multi-agent review (security + Oracle + API audit + scope)
- **`/health-check`** — Run at phase completion for comprehensive quality gate validation
- **`/prd --update`** — Called automatically at phase completion to mark satisfied requirements as [IMPLEMENTED]

### Referenced Protocols

- **QA Watcher Protocol** — `.claude/reference/phase-10-task-plan.md` section "Continuous QA Watcher Protocol"
- **Phase Dependency DAG** — A→B→C, A→D, A→F, B→E (from task plan header)

### Claude Code Native Tools Used

- `TeamCreate` / `TeamDelete` — Team lifecycle (**must happen before TaskCreate**)
- `TaskCreate` / `TaskUpdate` / `TaskList` / `TaskGet` — Ledger operations (scoped to team namespace)
- `Task` tool — Spawning agents with `isolation: "worktree"`, `run_in_background: true`, `model`, `max_turns`
- `TaskOutput` — Polling background agents for completion (non-blocking with `block: false`)

## Examples

- `/orchestrate A` — Run Phase A (Dependency Updates + Fastify Hardening)
- `/orchestrate A --dry-run` — Preview Phase A tasks with generated prompts
- `/orchestrate A --wave 2` — Resume Phase A from Wave 2
- `/orchestrate A --max-agents 3` — Run Phase A with at most 3 concurrent agents
- `/orchestrate A --max-turns 80` — Override default turns per agent
- `/orchestrate docs/plans/custom-plan.md` — Orchestrate from a custom plan file (auto-detects PRD traceability)
- `/orchestrate "add auth middleware; write auth tests; update docs"` — Inline tasks (no PRD)
- `/orchestrate docs/plans/search-plan.md --no-prd` — Run plan without PRD feedback loop

## Error Recovery

- **Agent exceeds max_turns**: Auto-stops, enters failure escalation (retry → model escalation → user)
- **Merge conflict**: Abort merge, create fix task, assign to available agent or pause for user
- **Quality gate fails**: Create fix task, spawn fix agent, re-run gate
- **All agents stuck**: Report to user, suggest manual intervention or restart
- **Git worktree issues**: Run `git worktree prune` to clean up stale worktrees
- **PRD update fails**: Log the coverage map to `docs/plans/<feature>-coverage.md` as fallback — the user can run `/prd --update` manually with the logged requirement IDs
