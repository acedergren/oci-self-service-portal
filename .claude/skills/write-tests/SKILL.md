---
name: write-tests
description: >-
  Add test coverage to existing code with project-correct vitest mock patterns.
  Use when adding tests to untested modules, writing regression tests for bugs,
  or user asks to test a specific file. Handles mockReset:true, vi.hoisted(),
  forwarding pattern, and Fastify 5 buildTestApp() utilities.
---

# Write Tests for Existing Code

## Before Writing, Ask Yourself

- **Module type?** Route handler, repository, plugin, utility, or service — each has a different mock strategy (see table below)
- **Blast radius?** Does this module have side effects (DB writes, API calls) that need isolation?
- **Nearest test file?** Find the closest `*.test.ts` and match its structure exactly

## Mock Strategy by Module Type

| Module Type    | Strategy                                                | Reference                                     |
| -------------- | ------------------------------------------------------- | --------------------------------------------- |
| Route handler  | `buildTestApp()` + `simulateSession()` + `app.inject()` | `apps/api/src/tests/routes/test-helpers.ts`   |
| Repository     | Mock `withConnection` + counter-based `execute`         | `apps/api/src/tests/admin/mcp-server.test.ts` |
| Fastify plugin | Real Fastify instance + selective dependency mocks      | `apps/api/src/plugins/cors.test.ts`           |
| Pure utility   | No mocks — test inputs/outputs directly                 | —                                             |
| Service w/ DI  | Mock injected deps via forwarding pattern               | —                                             |

## Mock Setup (mockReset: true)

This codebase uses `mockReset: true`. Most Vitest examples from the internet will **silently fail** here.

```typescript
const { mockFn } = vi.hoisted(() => ({
	mockFn: vi.fn()
}));

vi.mock('./dependency', () => ({
	dependency: (...args: unknown[]) => mockFn(...args)
}));

beforeEach(() => {
	// MUST reconfigure here — mockReset clears return values between tests
	mockFn.mockResolvedValue(defaultResult);
});
```

For complex TDZ cases (multiple interdependent mocks), use the **globalThis registry pattern** — see CLAUDE.md §4.

## NEVER

- **NEVER chain `mockResolvedValueOnce`** — `mockReset` clears the chain between tests, so only the first test in a suite works. Use counter-based `mockImplementation` with a `callCount` variable.
- **NEVER define mock variables at module scope then reference in `vi.mock()` factories** — hoisting creates a temporal dead zone. Use `vi.hoisted()` or globalThis registry.
- **NEVER `vi.importActual()` for modules with side effects** — use selective re-exports instead.
- **NEVER test implementation details** (private state, internal call order) — test behavior through the public API. Tests coupled to internals break on every refactor.
- **NEVER copy mock patterns from other projects** — `mockReset: true` makes standard Vitest patterns fail silently in this codebase.
- **NEVER modify source code** — this skill writes tests only. If the source needs changes, that's a separate task.

## Metacognitive Rule

**If >3 tests fail on first run**: STOP. The root cause is almost certainly a mock wiring issue affecting all tests, not individual test logic errors. Re-examine the mock setup strategy holistically before fixing tests one by one.

## Run

```bash
pnpm vitest run <test-file> --reporter=verbose
```

## Arguments

- `$ARGUMENTS`: Path to the source file or module to cover
  - Example: `/write-tests apps/api/src/routes/admin/settings.ts`
  - If empty, ask the user which file needs test coverage
